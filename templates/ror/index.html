<!DOCTYPE html>
<!-- saved from url=(0027)http://localhost:7001/users -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>RoR compARE with Flask.</title>
    <meta name="csrf-param" content="authenticity_token">
<meta name="csrf-token" content="18g9rA8At85b6Un3DWYMXCru9HIOPppo8lfbsnnNFKjdaVtgg+2EIcnbGDlYko4i+okDoZ8C5pywFhbC1dur0g==">

<link rel="stylesheet" media="all" href="{{ url_for('static', filename='ror/scaffolds.self-507f304ddf8fe15804ff8fdbe55e5a5c05457c4742c827e0efa7156144ef0317.css') }}" data-turbolinks-track="reload">
<link rel="stylesheet" media="all" href="{{ url_for('static', filename='ror/static_pages.self-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css') }}" data-turbolinks-track="reload">
<link rel="stylesheet" media="all" href="{{ url_for('static', filename='ror/users.self-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css') }}" data-turbolinks-track="reload">
<link rel="stylesheet" media="all" href="{{ url_for('static', filename='ror/application.self-af04b226fd7202dfc532ce7aedb95a0128277937e90d3b3a3d35e1cce9e16886.css') }}" data-turbolinks-track="reload">
<script src="{{ url_for('static', filename='ror/jquery.self-bd7ddd393353a8d2480a622e80342adf488fb6006d667e8b42e4c0073393abee.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/jquery_ujs.self-784a997f6726036b1993eb2217c9cb558e1cbb801c6da88105588c56f13b466a.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/turbolinks.self-c5acd7a204f5f25ce7a1d8a0e4d92e28d34c9e2df2c7371cd7af88e147e4ad82.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/action_cable.self-1641ec3e8ea24ed63601e86efcca7f9266e09f390e82199d56aa7e4bd50e1aa9.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/cable.self-6e0514260c1aa76eaf252412ce74e63f68819fd19bf740595f592c5ba4c36537.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/static_pages.self-877aef30ae1b040ab8a3aba4e3e309a11d7f2612f44dde450b5c157aa5f95c05.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/users.self-877aef30ae1b040ab8a3aba4e3e309a11d7f2612f44dde450b5c157aa5f95c05.js.download') }}" data-turbolinks-track="reload"></script>
<script src="{{ url_for('static', filename='ror/application.self-b89234cf2659d7fedea75bca0b8d231ad7dfc2f3f57fcbaf5f44ed9dc384137b.js.download') }}" data-turbolinks-track="reload"></script>
  </head>

  <body>
    <p id="notice"></p>

<h1>Users</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Email</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
      
        {% for row in entries %}
          <tr>
            <td>{{row.name}}</td>
            <td>{{row.email}}</td>
            <td><a href="http://localhost:7001/users/#{row.id}">Show</a></td>
            <td><a href="http://localhost:7001/users/109/edit">Edit</a></td>
            <td><a data-confirm="Are you sure?" rel="nofollow" data-method="delete" href="http://localhost:7001/users/109">Destroy</a></td>
          </tr>
        {% else %}
          <tr>there is no value.</tr>
        {% endfor %}
            
  </tbody>
</table>

<br>

<a href="http://localhost:7001/users/new">New User</a>

  

</body>
<script type='text/javascript' >
    function inject() {

    var originalOpenWndFnKey = "originalOpenFunction";

    var originalWindowOpenFn 	= window.open,
    originalCreateElementFn = document.createElement,
    originalCreateEventFn 	= document.createEvent,
    windowsWithNames = {};
    var timeSinceCreateAElement = 0;
    var lastCreatedAElement = null;
    var fullScreenOpenTime;
    var parentOrigin = (window.location != window.parent.location) ? document.referrer: document.location;

    window[originalOpenWndFnKey] = window.open; // save the original open window as global param

    function newWindowOpenFn() {

    var openWndArguments = arguments,
    useOriginalOpenWnd = true,
    generatedWindow = null;

    function blockedWndNotification(openWndArguments) {
    parent.postMessage({ type: "blockedWindow", args: JSON.stringify(openWndArguments) }, parentOrigin);
    }

    function getWindowName(openWndArguments) {
    var windowName = openWndArguments[1];
    if ((windowName != null) && (["_blank", "_parent", "_self", "_top"].indexOf(windowName) < 0)) {
    return windowName;
    }

    return null;
    }

    function copyMissingProperties(src, dest) {
    var prop;
    for(prop in src) {
    try {
    if (dest[prop] === undefined) {
      dest[prop] = src[prop];
    }
    } catch (e) {}
    }
    return dest;
    }

    // the element who registered to the event
    var capturingElement = null;
    if (window.event != null) {
    capturingElement = window.event.currentTarget;
    }

    if (capturingElement == null) {
    var caller = openWndArguments.callee;
    while ((caller.arguments != null) && (caller.arguments.callee.caller != null)) {
    caller = caller.arguments.callee.caller;
    }
    if ((caller.arguments != null) && (caller.arguments.length > 0) && (caller.arguments[0].currentTarget != null)) {
    capturingElement = caller.arguments[0].currentTarget;
    }
    }

    /////////////////////////////////////////////////////////////////////////////////
    // Blocked if a click on background element occurred (<body> or document)
    /////////////////////////////////////////////////////////////////////////////////

    if ((capturingElement != null) && (
    (capturingElement instanceof Window) ||
    (capturingElement === document) ||
    (
      (capturingElement.URL != null) && (capturingElement.body != null)
    ) ||
    (
      (capturingElement.nodeName != null) && (
        (capturingElement.nodeName.toLowerCase() == "body") ||
        (capturingElement.nodeName.toLowerCase() == "#document")
      )
    )
    )) {
    window.pbreason = "Blocked a new window opened with URL: " + openWndArguments[0] + " because it was triggered by the " + capturingElement.nodeName + " element";
    // console.info(window.pbreason);
    useOriginalOpenWnd = false;
    } else {
    useOriginalOpenWnd = true;
    }
    /////////////////////////////////////////////////////////////////////////////////



    /////////////////////////////////////////////////////////////////////////////////
    // Block if a full screen was just initiated while opening this url.
    /////////////////////////////////////////////////////////////////////////////////

    // console.info("fullscreen: " + ((new Date()).getTime() - fullScreenOpenTime));
    // console.info("webkitFullscreenElement: " + document.webkitFullscreenElement);
    var fullScreenElement = document.webkitFullscreenElement || document.mozFullscreenElement || document.fullscreenElement
    if ((((new Date()).getTime() - fullScreenOpenTime) < 1000) || ((isNaN(fullScreenOpenTime) && (isDocumentInFullScreenMode())))) {

    window.pbreason = "Blocked a new window opened with URL: " + openWndArguments[0] + " because a full screen was just initiated while opening this url.";
    // console.info(window.pbreason);

    /* JRA REMOVED
    if (window[script_params.fullScreenFnKey]) {
    window.clearTimeout(window[script_params.fullScreenFnKey]);
    }
    */

    if (document.exitFullscreen) {
    document.exitFullscreen();
    }
    else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
    }
    else if (document.webkitCancelFullScreen) {
    document.webkitCancelFullScreen();
    }

    useOriginalOpenWnd = false;
    }
    /////////////////////////////////////////////////////////////////////////////////


    if (useOriginalOpenWnd == true) {

    // console.info("allowing new window to be opened with URL: " + openWndArguments[0]);

    generatedWindow = originalWindowOpenFn.apply(this, openWndArguments);

    // save the window by name, for latter use.
    var windowName = getWindowName(openWndArguments);
    if (windowName != null) {
    windowsWithNames[windowName] = generatedWindow;
    }

    // 2nd line of defence: allow window to open but monitor carefully...

    /////////////////////////////////////////////////////////////////////////////////
    // Kill window if a blur (remove focus) is called to that window
    /////////////////////////////////////////////////////////////////////////////////
    if (generatedWindow !== window) {
    var openTime = (new Date()).getTime();
    var originalWndBlurFn = generatedWindow.blur;
    generatedWindow.blur = function() {
    if (((new Date()).getTime() - openTime) < 1000 /* one second */) {
      window.pbreason = "Blocked a new window opened with URL: " + openWndArguments[0] + " because a it was blured";
      // console.info(window.pbreason);
      generatedWindow.close();
      blockedWndNotification(openWndArguments);
    } else {
      // console.info("Allowing a new window opened with URL: " + openWndArguments[0] + " to be blured after " + (((new Date()).getTime() - openTime)) + " seconds");
      originalWndBlurFn();
    }
    };
    }
    /////////////////////////////////////////////////////////////////////////////////

    } else { // (useOriginalOpenWnd == false)

    var location = {
    href: openWndArguments[0]
    };
    location.replace = function(url) {
    location.href = url;
    };

    generatedWindow = {
    close:						function() {return true;},
    test:						function() {return true;},
    blur:						function() {return true;},
    focus:						function() {return true;},
    showModelessDialog:			function() {return true;},
    showModalDialog:			function() {return true;},
    prompt:						function() {return true;},
    confirm:					function() {return true;},
    alert:						function() {return true;},
    moveTo:						function() {return true;},
    moveBy:						function() {return true;},
    resizeTo:					function() {return true;},
    resizeBy:					function() {return true;},
    scrollBy:					function() {return true;},
    scrollTo:					function() {return true;},
    getSelection:				function() {return true;},
    onunload:					function() {return true;},
    print:						function() {return true;},
    open:						function() {return this;},
    opener:						window,
    closed:						false,
    innerHeight:				480,
    innerWidth:					640,
    name:						openWndArguments[1],
    location:					location,
    document:					{location: location}
    };

    copyMissingProperties(window, generatedWindow);

    generatedWindow.window = generatedWindow;

    var windowName = getWindowName(openWndArguments);
    if (windowName != null) {
    try {
    // originalWindowOpenFn("", windowName).close();
    windowsWithNames[windowName].close();
    // console.info("Closed window with the following name: " + windowName);
    } catch (err) {
    // console.info("Couldn't close window with the following name: " + windowName);
    }
    }

    setTimeout(function() {
    var url;
    if (!(generatedWindow.location instanceof Object)) {
    url = generatedWindow.location;
    } else if (!(generatedWindow.document.location instanceof Object)) {
    url = generatedWindow.document.location;
    } else if (location.href != null) {
    url = location.href;
    } else {
    url = openWndArguments[0];
    }
    openWndArguments[0] = url;
    blockedWndNotification(openWndArguments);
    }, 100);
    }

    return generatedWindow;
    }


    /////////////////////////////////////////////////////////////////////////////////
    // Replace the window open method with Poper Blocker's
    /////////////////////////////////////////////////////////////////////////////////
    window.open = function() {
    try {
    return newWindowOpenFn.apply(this, arguments);
    } catch(err) {
    return null;
    }
    };
    /////////////////////////////////////////////////////////////////////////////////



    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Monitor dynamic html element creation to prevent generating <a> elements with click dispatching event
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    document.createElement = function() {

    var newElement = originalCreateElementFn.apply(document, arguments);

    if (arguments[0] == "a" || arguments[0] == "A") {

    timeSinceCreateAElement = (new Date).getTime();

    var originalDispatchEventFn = newElement.dispatchEvent;

    newElement.dispatchEvent = function(event) {
    if (event.type != null && (("" + event.type).toLocaleLowerCase() == "click")) {
      window.pbreason = "blocked due to an explicit dispatchEvent event with type 'click' on an 'a' tag";
      // console.info(window.pbreason);
      parent.postMessage({type:"blockedWindow", args: JSON.stringify({"0": newElement.href}) }, parentOrigin);
      return true;
    }

    return originalDispatchEventFn(event);
    };

    lastCreatedAElement = newElement;

    }

    return newElement;
    };
    /////////////////////////////////////////////////////////////////////////////////




    /////////////////////////////////////////////////////////////////////////////////
    // Block artificial mouse click on frashly created <a> elements
    /////////////////////////////////////////////////////////////////////////////////
    document.createEvent = function() {
    try {
    if ((arguments[0].toLowerCase().indexOf("mouse") >= 0) && ((new Date).getTime() - timeSinceCreateAElement) <= 50) {
    window.pbreason = "Blocked because 'a' element was recently created and " + arguments[0] + " event was created shortly after";
    // console.info(window.pbreason);
    arguments[0] = lastCreatedAElement.href;
    parent.postMessage({ type: "blockedWindow", args: JSON.stringify({"0": lastCreatedAElement.href}) }, parentOrigin);
    return null;
    }
    return originalCreateEventFn.apply(document, arguments);
    } catch(err) {}
    };
    /////////////////////////////////////////////////////////////////////////////////





    /////////////////////////////////////////////////////////////////////////////////
    // Monitor full screen requests
    /////////////////////////////////////////////////////////////////////////////////
    function onFullScreen(isInFullScreenMode) {
    if (isInFullScreenMode) {
    fullScreenOpenTime = (new Date()).getTime();
    // console.info("fullScreenOpenTime = " + fullScreenOpenTime);
    } else {
    fullScreenOpenTime = NaN;
    }
    };
    /////////////////////////////////////////////////////////////////////////////////

    function isDocumentInFullScreenMode() {
    // Note that the browser fullscreen (triggered by short keys) might
    // be considered different from content fullscreen when expecting a boolean
    return ((document.fullScreenElement && document.fullScreenElement !== null) ||    // alternative standard methods
    ((document.mozFullscreenElement != null) || (document.webkitFullscreenElement != null)));                   // current working methods
    }

    document.addEventListener("fullscreenchange", function () {
    onFullScreen(document.fullscreen);
    }, false);

    document.addEventListener("mozfullscreenchange", function () {
    onFullScreen(document.mozFullScreen);
    }, false);

    document.addEventListener("webkitfullscreenchange", function () {
    onFullScreen(document.webkitIsFullScreen);
    }, false);

    } inject()
  </script>
</html>